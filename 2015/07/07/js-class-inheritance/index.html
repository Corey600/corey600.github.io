<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>JS的类和继承的实现方法比较 | Corey's Blog</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">JS的类和继承的实现方法比较</h1><a id="logo" href="/.">Corey's Blog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">JS的类和继承的实现方法比较</h1><div class="post-meta">Jul 7, 2015<span> | </span><span class="category"><a href="/categories/备忘/">备忘</a></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-创建对象的各种方式对比"><span class="toc-number">1.</span> <span class="toc-text">1.创建对象的各种方式对比</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#工厂模式"><span class="toc-number">1.1.</span> <span class="toc-text">工厂模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#构造函数模式"><span class="toc-number">1.2.</span> <span class="toc-text">构造函数模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#另一种函数构造模式"><span class="toc-number">1.3.</span> <span class="toc-text">另一种函数构造模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#原型模式"><span class="toc-number">1.4.</span> <span class="toc-text">原型模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#更简单的原型语法"><span class="toc-number">1.5.</span> <span class="toc-text">更简单的原型语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#组合使用构造函数和原型模式"><span class="toc-number">1.6.</span> <span class="toc-text">组合使用构造函数和原型模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#动态原型模式-（推荐方式）"><span class="toc-number">1.7.</span> <span class="toc-text">动态原型模式 （推荐方式）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#寄生构造函数模式"><span class="toc-number">1.8.</span> <span class="toc-text">寄生构造函数模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#稳妥构造函数模式"><span class="toc-number">1.9.</span> <span class="toc-text">稳妥构造函数模式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-实现继承的各种方式对比"><span class="toc-number">2.</span> <span class="toc-text">2. 实现继承的各种方式对比</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#原型链"><span class="toc-number">2.1.</span> <span class="toc-text">原型链</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#借用构造函数"><span class="toc-number">2.2.</span> <span class="toc-text">借用构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#组合继承-（最常用）"><span class="toc-number">2.3.</span> <span class="toc-text">组合继承 （最常用）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#寄生组合式继承"><span class="toc-number">2.4.</span> <span class="toc-text">寄生组合式继承</span></a></li></ol></li></ol></div></div><div class="post-content"><h4 id="1-创建对象的各种方式对比"><a href="#1-创建对象的各种方式对比" class="headerlink" title="1.创建对象的各种方式对比"></a>1.创建对象的各种方式对比</h4><h5 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.info(<span class="string">"工厂模式"</span>);</div><div class="line">    <span class="comment">// 工厂模式</span></div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">        o.name = name;</div><div class="line">        o.age = age;</div><div class="line">        o.job = job;</div><div class="line">        o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">return</span> o;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">var</span> person1 = createPerson(<span class="string">"name1"</span>, <span class="number">29</span>, <span class="string">"job1"</span>);</div><div class="line">    person1.sayName();</div><div class="line">    <span class="keyword">var</span> person2 = createPerson(<span class="string">"name2"</span>, <span class="number">30</span>, <span class="string">"job2"</span>);</div><div class="line">    person2.sayName();</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 优点：能创建相似对象。</div><div class="line">     * 缺点：不能识别对象。</div><div class="line">     */</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<a id="more"></a>
<h5 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.info(<span class="string">"构造函数模式"</span>);</div><div class="line">    <span class="comment">// 构造函数模式</span></div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">        <span class="keyword">this</span>.job = job;</div><div class="line">        <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"name1"</span>, <span class="number">29</span>, <span class="string">"job1"</span>);</div><div class="line">    person1.sayName();</div><div class="line">    <span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"name2"</span>, <span class="number">30</span>, <span class="string">"job2"</span>);</div><div class="line">    person2.sayName();</div><div class="line"> </div><div class="line">    <span class="built_in">console</span>.log(person1.constructor == Person); <span class="comment">// true</span></div><div class="line">    <span class="built_in">console</span>.log(person1.constructor == Person); <span class="comment">// true</span></div><div class="line"> </div><div class="line">    <span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></div><div class="line">    <span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></div><div class="line">    <span class="built_in">console</span>.log(person2 <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></div><div class="line">    <span class="built_in">console</span>.log(person2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 优点：创建自定义的构造函数意味着可以将它的实例标识为一种特定的类型。</div><div class="line">     * 缺点：每个方法都要在每个实例上重新创建一遍。</div><div class="line">     */</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<h5 id="另一种函数构造模式"><a href="#另一种函数构造模式" class="headerlink" title="另一种函数构造模式"></a>另一种函数构造模式</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.info(<span class="string">"另一种函数构造模式"</span>);</div><div class="line">    <span class="comment">// 另一种函数构造模式</span></div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">        <span class="keyword">this</span>.job = job;</div><div class="line">        <span class="keyword">this</span>.sayName = sayName;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"name1"</span>, <span class="number">29</span>, <span class="string">"job1"</span>);</div><div class="line">    person1.sayName();</div><div class="line">    <span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"name2"</span>, <span class="number">30</span>, <span class="string">"job2"</span>);</div><div class="line">    person2.sayName();</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 优点：不同对象能够共享在全局作用域中定义的同一个函数。</div><div class="line">     * 缺点：</div><div class="line">     * (1) 在全局作用域中定义的函数实际上只能被某个对象调用，这让全局作用域名不副实。</div><div class="line">     * (2) 如果对象定义很多方法，那么就要定义很多个全局函数，于是自定义的引用类型就失去了封</div><div class="line">     * 装性。</div><div class="line">     */</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<h5 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h5><figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">(<span class="name">function</span>()&#123;</div><div class="line">    console.info(<span class="string">"原型模式"</span>)<span class="comment">;</span></div><div class="line">    // 原型模式</div><div class="line"> </div><div class="line">    function Person()&#123;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    Person.prototype.name = <span class="string">"name1"</span><span class="comment">;</span></div><div class="line">    Person.prototype.age = <span class="number">29</span><span class="comment">;</span></div><div class="line">    Person.prototype.job = <span class="string">"job1"</span><span class="comment">;</span></div><div class="line">    Person.prototype.friends = [<span class="string">"f1"</span>, <span class="string">"f2"</span>]<span class="comment">;</span></div><div class="line">    Person.prototype.sayName = function()&#123;</div><div class="line">        console.log(<span class="name">this.name</span>)<span class="comment">;</span></div><div class="line">    &#125;<span class="comment">;</span></div><div class="line"> </div><div class="line">    var person1 = new Person()<span class="comment">;</span></div><div class="line">    person1.sayName()<span class="comment">; // name1</span></div><div class="line">    var person2 = new Person()<span class="comment">;</span></div><div class="line">    person2.sayName()<span class="comment">; // name1</span></div><div class="line"> </div><div class="line">    console.log(<span class="name">person1.sayName</span> == person2.sayName)<span class="comment">; // true</span></div><div class="line"> </div><div class="line">    // 确定是否是原型中的属性</div><div class="line">    function isPrototypeProperty(<span class="name">object</span>, name)&#123;</div><div class="line">        return (<span class="name">!object.hasOwnProperty</span>(<span class="name"><span class="builtin-name">name</span></span>)) &amp;&amp; (<span class="name"><span class="builtin-name">name</span></span> in object)<span class="comment">;</span></div><div class="line">    &#125;</div><div class="line">    console.log(<span class="name">isPrototypeProperty</span>(<span class="name">person1</span>, <span class="string">"name"</span>))<span class="comment">; // true</span></div><div class="line"> </div><div class="line">    person1.name = <span class="string">"name2"</span><span class="comment">;</span></div><div class="line">    console.log(<span class="name">person1.name</span>)<span class="comment">; // name2 —— 来自实例</span></div><div class="line">    console.log(<span class="name">person2.name</span>)<span class="comment">; // name1 —— 来自原型</span></div><div class="line">    console.log(<span class="name">isPrototypeProperty</span>(<span class="name">person1</span>, <span class="string">"name"</span>))<span class="comment">; // false</span></div><div class="line"> </div><div class="line">    delete person1.name;</div><div class="line">    console.log(<span class="name">person1.name</span>)<span class="comment">; // name1 —— 来自原型</span></div><div class="line"> </div><div class="line">    console.log(<span class="name">person1.friends</span>)<span class="comment">; // ["f1", "f2"]</span></div><div class="line">    console.log(<span class="name">person2.friends</span>)<span class="comment">; // ["f1", "f2"]</span></div><div class="line">    person1.friends.push(<span class="string">"f3"</span>)<span class="comment">;</span></div><div class="line">    console.log(<span class="name">person1.friends</span>)<span class="comment">; // ["f1", "f2", "f3"]</span></div><div class="line">    console.log(<span class="name">person2.friends</span>)<span class="comment">; // ["f1", "f2", "f3"]</span></div><div class="line">    console.log(<span class="name">person1.friends</span> == person2.friends)<span class="comment">; // true</span></div><div class="line"> </div><div class="line">    /**</div><div class="line">     * 优点：所有对象实例能够共享原型的属性和方法。</div><div class="line">     * 缺点：</div><div class="line">     * (<span class="number">1</span>) 不能通过对象实例重写原型中的值，如果在实例中添加一个同名属性，就是在实例中创建了</div><div class="line">     * 该属性，屏蔽了原型中的那个属性。删除该同名属性可以恢复对原型中属性的链接。</div><div class="line">     * (<span class="number">2</span>) 所有实例在默认情况下都将取得相同的属性值。</div><div class="line">     * (<span class="number">3</span>) 原型中的所有属性都是被实例共享的。这个问题对于包含引用类型值的属性来说比较突出。</div><div class="line">     */</div><div class="line">&#125;())<span class="comment">;</span></div></pre></td></tr></table></figure>
<h5 id="更简单的原型语法"><a href="#更简单的原型语法" class="headerlink" title="更简单的原型语法"></a>更简单的原型语法</h5><figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">(<span class="name">function</span>()&#123;</div><div class="line">    console.info(<span class="string">"更简单的原型语法"</span>)<span class="comment">;</span></div><div class="line">    // 更简单的原型语法</div><div class="line"> </div><div class="line">    function Person()&#123;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    var prePerson = new Person()<span class="comment">;</span></div><div class="line"> </div><div class="line">    // 重写原型对象</div><div class="line">    Person.prototype = &#123;</div><div class="line">        name : <span class="string">"name1"</span>,</div><div class="line">        age : <span class="number">29</span>,</div><div class="line">        job : <span class="string">"job1"</span>,</div><div class="line">        sayName : function()&#123;</div><div class="line">            console.log(<span class="name">this.name</span>)<span class="comment">;</span></div><div class="line">        &#125;</div><div class="line">    &#125;<span class="comment">;</span></div><div class="line"> </div><div class="line">    // prePerson.sayName()<span class="comment">; // 出错</span></div><div class="line"> </div><div class="line">    var person = new Person()<span class="comment">;</span></div><div class="line"> </div><div class="line">    console.log(<span class="name">person</span> instanceof Object)<span class="comment">; // true</span></div><div class="line">    console.log(<span class="name">person</span> instanceof Person)<span class="comment">; // true</span></div><div class="line">    console.log(<span class="name">person.constructor</span> == Object)<span class="comment">; // true</span></div><div class="line">    console.log(<span class="name">person.constructor</span> == Person)<span class="comment">; // false</span></div><div class="line"> </div><div class="line">    // 重新设置constructor的值</div><div class="line">    Person.prototype.constructor = Person;</div><div class="line">    console.log(<span class="name">person.constructor</span> == Person)<span class="comment">; // true</span></div><div class="line"> </div><div class="line">    // 以下代码只适用于ECMAScript5 兼容的浏览器</div><div class="line">    console.log(<span class="name">Object.keys</span>(<span class="name">Person.prototype</span>))<span class="comment">; // ["name", "age", "job", "sayName", "constructor"]</span></div><div class="line">    Object.defineProperty(<span class="name">Person.prototype</span>, <span class="string">"constructor"</span>, &#123;</div><div class="line">        enumerable : <span class="literal">false</span>,</div><div class="line">        value : Person</div><div class="line">    &#125;)<span class="comment">;</span></div><div class="line">    console.log(<span class="name">Object.keys</span>(<span class="name">Person.prototype</span>))<span class="comment">; // ["name", "age", "job", "sayName"]</span></div><div class="line"> </div><div class="line">    /**</div><div class="line">     * 优点：相比于之前的原型语法，减少了不必要的输入，从视觉上更好地封装了原型的功能。</div><div class="line">     * 缺点：</div><div class="line">     * (<span class="number">1</span>) 具有之前的原型模式的全部三个缺点。</div><div class="line">     * (<span class="number">2</span>) 本质上重写了默认的prototype对象，因此constructor属性也变成了新的对象的</div><div class="line">     * constructor属性(指向Object构造函数)， 不再指向Person函数。当然也可以重新设置</div><div class="line">     * constructor值，但是这样会导致它的[[Enumerable]]特性被设置为<span class="literal">true</span>，单是原生的</div><div class="line">     * constructor属性是不可枚举的。此时就需要使用ECMAScript5的特性来重设。</div><div class="line">     * (<span class="number">3</span>) 重写原型对象切断了现有原型和任何之前已经存在的对象实例之间的联系，在重写原型</div><div class="line">     * 之前创建的对象实例引用的仍然是最初的原型（原型的动态性）。</div><div class="line">     */</div><div class="line">&#125;())<span class="comment">;</span></div></pre></td></tr></table></figure>
<h5 id="组合使用构造函数和原型模式"><a href="#组合使用构造函数和原型模式" class="headerlink" title="组合使用构造函数和原型模式"></a>组合使用构造函数和原型模式</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.info(<span class="string">"组合使用构造函数和原型模式"</span>);</div><div class="line">    <span class="comment">// 组合使用构造函数和原型模式</span></div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">        <span class="keyword">this</span>.job = job;</div><div class="line">        <span class="keyword">this</span>.friends = [<span class="string">"f1"</span>, <span class="string">"f2"</span>];</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    Person.prototype = &#123;</div><div class="line">        <span class="attr">constructor</span> : Person,</div><div class="line">        <span class="attr">sayName</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"> </div><div class="line">    <span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"name1"</span>, <span class="number">29</span>, <span class="string">"job1"</span>);</div><div class="line">    person1.sayName();</div><div class="line">    <span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"name2"</span>, <span class="number">30</span>, <span class="string">"job2"</span>);</div><div class="line">    person2.sayName();</div><div class="line"> </div><div class="line">    <span class="built_in">console</span>.log(person1.friends); <span class="comment">// ["f1", "f2"]</span></div><div class="line">    <span class="built_in">console</span>.log(person2.friends); <span class="comment">// ["f1", "f2"]</span></div><div class="line">    person1.friends.push(<span class="string">"f3"</span>);</div><div class="line">    <span class="built_in">console</span>.log(person1.friends); <span class="comment">// ["f1", "f2", "f3"]</span></div><div class="line">    <span class="built_in">console</span>.log(person2.friends); <span class="comment">// ["f1", "f2"]</span></div><div class="line">    <span class="built_in">console</span>.log(person1.friends == person2.friends); <span class="comment">// false</span></div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 优点：实例属性在构造函数中定义，所有实例共享的属性和方法在原型中定义。</div><div class="line">     * 缺点：独立的构造函数和原型使人困惑。</div><div class="line">     */</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<h5 id="动态原型模式-（推荐方式）"><a href="#动态原型模式-（推荐方式）" class="headerlink" title="动态原型模式 （推荐方式）"></a>动态原型模式 （推荐方式）</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.info(<span class="string">"动态原型模式"</span>);</div><div class="line">    <span class="comment">// 动态原型模式 （推荐方式）</span></div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line"> </div><div class="line">        <span class="comment">// 属性</span></div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">        <span class="keyword">this</span>.job = job;</div><div class="line"> </div><div class="line">        <span class="comment">// 方法</span></div><div class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>)&#123;</div><div class="line">            <span class="comment">// 不能使用字面量重写原型，否则会切断现有实例与新原型之间的联系</span></div><div class="line">            Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"name1"</span>, <span class="number">29</span>, <span class="string">"job1"</span>);</div><div class="line">    person.sayName();</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 优点：</div><div class="line">     * (1) 把所有信息都封装在了构造函数中.</div><div class="line">     * (2) 只在有必要时初始化原型。</div><div class="line">     * (3) 对原型所做的修改能够立即在所有实例中得到反映。</div><div class="line">     * (4) 实例属性在构造函数中定义，所有实例共享的属性和方法在原型中定义。</div><div class="line">     * 缺点：不能使用字面量重写原型。</div><div class="line">     */</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<h5 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.info(<span class="string">"寄生构造函数模式"</span>);</div><div class="line">    <span class="comment">// 寄生构造函数模式</span></div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">MyArray</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="comment">// 创建数组</span></div><div class="line">        <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"> </div><div class="line">        <span class="comment">// 添加值</span></div><div class="line">        values.push.apply(values,  <span class="built_in">arguments</span>);</div><div class="line"> </div><div class="line">        <span class="comment">// 添加方法</span></div><div class="line">        values.toPipedString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">"|"</span>);</div><div class="line">        &#125;;</div><div class="line"> </div><div class="line">        <span class="comment">// 返回数组</span></div><div class="line">        <span class="keyword">return</span> values;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">var</span> colors = <span class="keyword">new</span> MyArray(<span class="string">"col1"</span>, <span class="string">"col2"</span>, <span class="string">"col3"</span>);</div><div class="line">    <span class="built_in">console</span>.log(colors.toPipedString());</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 说明：《javascript高级程序设计第三版》 p160</div><div class="line">     * &gt;除了使用new操作符并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实已一模一</div><div class="line">     * 样的。构造函数在不返回值的情况下，默认返回新的对象实例。而通过在构造函数的末尾添加</div><div class="line">     * 一个return语句，重写了调用构造函数时的返回值。</div><div class="line">     */</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 优点：能在不修改原生类型的情况下，创建具有额外方法的扩展原生类型的对象。</div><div class="line">     * 缺点：返回的对象与构造函数或者与构造函数的原型属性之间没有关系，不能依赖instanceof</div><div class="line">     * 操作符来确定对象类型。</div><div class="line">     */</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<h5 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.info(<span class="string">"稳妥构造函数模式"</span>);</div><div class="line">    <span class="comment">// 稳妥构造函数模式</span></div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line">        <span class="comment">// 创建要返回的对象</span></div><div class="line">        <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"> </div><div class="line">        <span class="comment">// 可以在这里定义私有变量和函数</span></div><div class="line"> </div><div class="line">        <span class="comment">// 添加方法</span></div><div class="line">        o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(name);</div><div class="line">        &#125;;</div><div class="line"> </div><div class="line">        <span class="comment">// 返回对象</span></div><div class="line">        <span class="keyword">return</span> o;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">var</span> person = Person(<span class="string">"name1"</span>, <span class="number">29</span>, <span class="string">"job1"</span>);</div><div class="line">    person.sayName();</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 说明：《javascript高级程序设计第三版》 p161</div><div class="line">     * &gt;所谓的稳妥对象，指的是没有公共属性，而且其方法也不引用this的对象。稳妥对象最适合在</div><div class="line">     * 一些安全的环境中(这些环境中会禁用this和new)，或者在防止数据被其他应用程序(如Mashup</div><div class="line">     * 程序)改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建</div><div class="line">     * 对象的实例方法不引用this；二是不使用new操作符调用构造函数。</div><div class="line">     */</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 优点：除了调用方法外，没有别的方式可以访问其数据成员。</div><div class="line">     * 缺点：返回的对象与构造函数或者与构造函数的原型属性之间没有关系，不能依赖instanceof</div><div class="line">     * 操作符来确定对象类型。</div><div class="line">     */</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<h4 id="2-实现继承的各种方式对比"><a href="#2-实现继承的各种方式对比" class="headerlink" title="2. 实现继承的各种方式对比"></a>2. 实现继承的各种方式对比</h4><h5 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.info(<span class="string">"原型链"</span>);</div><div class="line">    <span class="comment">// 原型链</span></div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">this</span>.property = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">this</span>.colors = [<span class="string">"col1"</span>, <span class="string">"col2"</span>];</div><div class="line">    &#125;</div><div class="line">    SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.property;</div><div class="line">    &#125;;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">this</span>.subproperty = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    SubType.prototype = <span class="keyword">new</span> SuperType();</div><div class="line">    SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</div><div class="line">    &#125;;</div><div class="line"> </div><div class="line">    <span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</div><div class="line">    <span class="built_in">console</span>.log(instance1.getSuperValue());</div><div class="line"> </div><div class="line">    <span class="built_in">console</span>.log(instance1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></div><div class="line">    <span class="built_in">console</span>.log(instance1 <span class="keyword">instanceof</span> SuperType); <span class="comment">// true</span></div><div class="line">    <span class="built_in">console</span>.log(instance1 <span class="keyword">instanceof</span> SubType); <span class="comment">// true</span></div><div class="line"> </div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.isPrototypeOf(instance1)); <span class="comment">// true</span></div><div class="line">    <span class="built_in">console</span>.log(SuperType.prototype.isPrototypeOf(instance1)); <span class="comment">// true</span></div><div class="line">    <span class="built_in">console</span>.log(SubType.prototype.isPrototypeOf(instance1)); <span class="comment">// true</span></div><div class="line"> </div><div class="line">    <span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</div><div class="line">    instance1.colors.push(<span class="string">"col3"</span>);</div><div class="line">    <span class="built_in">console</span>.log(instance1.colors); <span class="comment">// ["col1", "col2", "col3"]</span></div><div class="line">    <span class="built_in">console</span>.log(instance2.colors); <span class="comment">// ["col1", "col2", "col3"]</span></div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 优点：使用instanceof操作符来测试实例与原型链中出现的构造函数，都返回true。同样，只</div><div class="line">     * 要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型，因此isPrototypeOf()</div><div class="line">     * 方法也会返回true.</div><div class="line">     * 缺点：</div><div class="line">     * (1) 不能使用对象字面量创建原型方法，因为这样会重写原型链。</div><div class="line">     * (2) 子类的原型实际上是超类的实例，超类中包含引用类型值的原型属性会被所有实例共享。</div><div class="line">     * (3) 不能在不影响所有实例的情况下给超类的构造函数传递参数。</div><div class="line">     */</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<h5 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.info(<span class="string">"借用构造函数"</span>);</div><div class="line">    <span class="comment">// 借用构造函数</span></div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="comment">// 继承了 SuperType，同时还传递了参数</span></div><div class="line">        SuperType.call(<span class="keyword">this</span>, <span class="string">"name1"</span>);</div><div class="line"> </div><div class="line">        <span class="comment">// 实例属性</span></div><div class="line">        <span class="keyword">this</span>.age = <span class="number">29</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</div><div class="line">    <span class="built_in">console</span>.log(instance.name);</div><div class="line">    <span class="built_in">console</span>.log(instance.age);</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 优点：可以在子类型构造函数中向超类型构造函数传递参数。</div><div class="line">     * 缺点：方法只能在构造函数中定义，在超类原型中定义的方法对于子类型是不可见的。</div><div class="line">     */</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<h5 id="组合继承-（最常用）"><a href="#组合继承-（最常用）" class="headerlink" title="组合继承 （最常用）"></a>组合继承 （最常用）</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.info(<span class="string">"组合继承"</span>);</div><div class="line">    <span class="comment">// 组合继承 （最常用）</span></div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.colors = [<span class="string">"col1"</span>, <span class="string">"col2"</span>];</div><div class="line">    &#125;</div><div class="line">    SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line"> </div><div class="line">    &#125;;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</div><div class="line">        <span class="comment">// 继承属性</span></div><div class="line">        SuperType.call(<span class="keyword">this</span>, name);</div><div class="line"> </div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">// 继承方法</span></div><div class="line">    SubType.prototype = <span class="keyword">new</span> SuperType();</div><div class="line"> </div><div class="line">    SubType.prototype.constructor = SubType;</div><div class="line">    SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</div><div class="line">    &#125;;</div><div class="line"> </div><div class="line">    <span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"name1"</span>, <span class="number">29</span>);</div><div class="line">    instance1.colors.push(<span class="string">"col3"</span>);</div><div class="line">    <span class="built_in">console</span>.log(instance1.colors); <span class="comment">// ["col1", "col2", "col3"]</span></div><div class="line">    instance1.sayName(); <span class="comment">// name1</span></div><div class="line">    instance1.sayAge(); <span class="comment">// 29</span></div><div class="line"> </div><div class="line">    <span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"name2"</span>, <span class="number">27</span>);</div><div class="line">    <span class="built_in">console</span>.log(instance2.colors); <span class="comment">// ["col1", "col2"]</span></div><div class="line">    instance2.sayName(); <span class="comment">// name2</span></div><div class="line">    instance2.sayAge(); <span class="comment">// 27</span></div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 优点：</div><div class="line">     * (1) 使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承。</div><div class="line">     * 这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。</div><div class="line">     * (2) instanceof 和 isPrototypeOf() 也能够用于识别基于组合继承创建的对象。</div><div class="line">     * 缺点：无论在什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。</div><div class="line">     * 子类型最终会包含超类型对象的全部实例属性，但不得不在调用子类型构造函数时重写这些属性。</div><div class="line">     */</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<h5 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h5><figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">(<span class="name">function</span>()&#123;</div><div class="line">    console.info(<span class="string">"寄生组合式继承"</span>)<span class="comment">;</span></div><div class="line">    // 寄生组合式继承</div><div class="line"> </div><div class="line">    function object(<span class="name">o</span>)&#123;</div><div class="line">        function F()&#123;&#125;</div><div class="line">        F.prototype = o;</div><div class="line">        return new F()<span class="comment">;</span></div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    function inheritPrototype(<span class="name">subType</span>, superType)&#123;</div><div class="line">        var prototype = Object(<span class="name">superType.prototype</span>)<span class="comment">; // 创建对象,和var prototype = superType.prototype;等效？</span></div><div class="line">        prototype.constructor = subType; // 增强对象 bug: 这里实际上是把superType.prototype.constructor改成了subType</div><div class="line">        subType.prototype = prototype; // 指定对象</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    function SuperType(<span class="name"><span class="builtin-name">name</span></span>)&#123;</div><div class="line">        this.name = name;</div><div class="line">        this.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]<span class="comment">;</span></div><div class="line">    &#125;</div><div class="line">    SuperType.prototype.sayName = function()&#123;</div><div class="line">        alert(<span class="name">this.name</span>)<span class="comment">;</span></div><div class="line">    &#125;<span class="comment">;</span></div><div class="line"> </div><div class="line">    var instance1 = new SuperType()<span class="comment">;</span></div><div class="line"> </div><div class="line">    console.log(<span class="name">instance1</span> instanceof Object)<span class="comment">; // true</span></div><div class="line">    console.log(<span class="name">instance1</span> instanceof SuperType)<span class="comment">; // true</span></div><div class="line">    console.log(<span class="name">instance1</span> instanceof SubType)<span class="comment">; // false</span></div><div class="line"> </div><div class="line">    console.log(<span class="name">Object.prototype.isPrototypeOf</span>(<span class="name">instance1</span>))<span class="comment">; // true</span></div><div class="line">    console.log(<span class="name">SuperType.prototype.isPrototypeOf</span>(<span class="name">instance1</span>))<span class="comment">; // true</span></div><div class="line">    console.log(<span class="name">SubType.prototype.isPrototypeOf</span>(<span class="name">instance1</span>))<span class="comment">; // false</span></div><div class="line"> </div><div class="line">    function SubType(<span class="name"><span class="builtin-name">name</span></span>, age)&#123;</div><div class="line">        SuperType.call(<span class="name">this</span>, name)<span class="comment">;</span></div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line">    inheritPrototype(<span class="name">SubType</span>, SuperType)<span class="comment">;</span></div><div class="line">    SubType.prototype.sayAge = function()&#123;</div><div class="line">        alert(<span class="name">this.age</span>)<span class="comment">;</span></div><div class="line">    &#125;<span class="comment">;</span></div><div class="line"> </div><div class="line">    console.log(<span class="name">instance1</span> instanceof Object)<span class="comment">; // true</span></div><div class="line">    console.log(<span class="name">instance1</span> instanceof SuperType)<span class="comment">; // true</span></div><div class="line">    console.log(<span class="name">instance1</span> instanceof SubType)<span class="comment">; // true</span></div><div class="line"> </div><div class="line">    console.log(<span class="name">Object.prototype.isPrototypeOf</span>(<span class="name">instance1</span>))<span class="comment">; // true</span></div><div class="line">    console.log(<span class="name">SuperType.prototype.isPrototypeOf</span>(<span class="name">instance1</span>))<span class="comment">; // true</span></div><div class="line">    console.log(<span class="name">SubType.prototype.isPrototypeOf</span>(<span class="name">instance1</span>))<span class="comment">; // true</span></div><div class="line"> </div><div class="line">    /**</div><div class="line">     * 优点：只调用了一次SuperType构造函数，并且因此避免了在SubType.prototype上创建不必要的、多余的属性。</div><div class="line">     * 缺点：事实上在调用inheritPrototype方法时，会把superType.prototype.constructor改成subType，</div><div class="line">     * 使得对一个超类的实例使用instanceof和SubType.prototype.isPrototypeOf的结果在调用inheritPrototype前后会发生变化。</div><div class="line">     * 为了避免这个问题可以使用：</div><div class="line">     * function object(<span class="name">o</span>)&#123;</div><div class="line">         *     function F()&#123;&#125;</div><div class="line">         *     F.prototype = o;</div><div class="line">         *     return new F()<span class="comment">;</span></div><div class="line">         * &#125;</div><div class="line">     * 即object(<span class="name">superType.prototype</span>)来代替上文的Object(<span class="name">superType.prototype</span>)。</div><div class="line">     * 或者直接使用Object.create(<span class="name">superType.prototype</span>)，即创建一个原型为等于superType.prototype的实例，</div><div class="line">     * 但值得注意的是Object.create只有IE <span class="number">9</span>+ Firefox <span class="number">4</span>+ Safari <span class="number">5</span>+ Opera <span class="number">12</span>+ 和 Chrome才支持。</div><div class="line">     */</div><div class="line">&#125;())<span class="comment">;</span></div></pre></td></tr></table></figure>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="https://corey600.github.io/2015/07/07/js-class-inheritance/" data-id="cj1q6aj3i001608qd4oeemhrx" class="article-share-link">分享到</a><div class="tags"><a href="/tags/javascript/">javascript</a><a href="/tags/类/">类</a><a href="/tags/继承/">继承</a></div><div class="post-nav"><a href="/2015/08/11/vagrant-instructions/" class="pre">使用vagrant虚拟机开发调试</a><a href="/2015/06/16/fiddler-instructions/" class="next">Fiddler使用说明</a></div><div class="comments-link-to"><span>想添加评论吗？给</span><span class="comments-email-to">我 (fcx600#163.com)</span><span>发邮件吧。或者请移步</span><a href="https://github.com/Corey600/static-blog/issues/new" target="_blank">这里</a><span>提交。</span></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/备忘/">备忘</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/总结/">总结</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/转载/">转载</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/04/20/react-international/">React多语言方案</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/15/node-performance-analysis/">由一个简单Node服务引申的Node性能分析方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/28/koa-and-co/">koa和co的简单分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/03/node-dubbo/">使用node开发dubbo远程调用客户端</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/22/private-npm-service/">私有NPM服务搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/13/gulp-workflow/">gulp前端构建工作流</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/04/flash-player/">Flash播放器研究</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/11/vagrant-instructions/">使用vagrant虚拟机开发调试</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/07/07/js-class-inheritance/">JS的类和继承的实现方法比较</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/06/16/fiddler-instructions/">Fiddler使用说明</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/ACM/" style="font-size: 15px;">ACM</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/串口/" style="font-size: 15px;">串口</a> <a href="/tags/LCD/" style="font-size: 15px;">LCD</a> <a href="/tags/Vim/" style="font-size: 15px;">Vim</a> <a href="/tags/Ubuntu/" style="font-size: 15px;">Ubuntu</a> <a href="/tags/SublimeText2/" style="font-size: 15px;">SublimeText2</a> <a href="/tags/G/" style="font-size: 15px;">G++</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Github/" style="font-size: 15px;">Github</a> <a href="/tags/Octopress/" style="font-size: 15px;">Octopress</a> <a href="/tags/Win7/" style="font-size: 15px;">Win7</a> <a href="/tags/VBox/" style="font-size: 15px;">VBox</a> <a href="/tags/Jekyll/" style="font-size: 15px;">Jekyll</a> <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/夏令时/" style="font-size: 15px;">夏令时</a> <a href="/tags/字符串/" style="font-size: 15px;">字符串</a> <a href="/tags/前端/" style="font-size: 15px;">前端</a> <a href="/tags/Fiddler/" style="font-size: 15px;">Fiddler</a> <a href="/tags/TQ2440/" style="font-size: 15px;">TQ2440</a> <a href="/tags/类/" style="font-size: 15px;">类</a> <a href="/tags/继承/" style="font-size: 15px;">继承</a> <a href="/tags/flash/" style="font-size: 15px;">flash</a> <a href="/tags/播放器/" style="font-size: 15px;">播放器</a> <a href="/tags/vagrant/" style="font-size: 15px;">vagrant</a> <a href="/tags/nfs/" style="font-size: 15px;">nfs</a> <a href="/tags/fis/" style="font-size: 15px;">fis</a> <a href="/tags/npm/" style="font-size: 15px;">npm</a> <a href="/tags/cnpm/" style="font-size: 15px;">cnpm</a> <a href="/tags/gulp/" style="font-size: 15px;">gulp</a> <a href="/tags/webpack/" style="font-size: 15px;">webpack</a> <a href="/tags/Node/" style="font-size: 15px;">Node</a> <a href="/tags/性能/" style="font-size: 15px;">性能</a> <a href="/tags/node/" style="font-size: 15px;">node</a> <a href="/tags/dubbo/" style="font-size: 15px;">dubbo</a> <a href="/tags/koa/" style="font-size: 15px;">koa</a> <a href="/tags/co/" style="font-size: 15px;">co</a> <a href="/tags/React/" style="font-size: 15px;">React</a> <a href="/tags/i18n/" style="font-size: 15px;">i18n</a></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Corey's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>