<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>koa和co的简单分析 | Corey's Blog</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">koa和co的简单分析</h1><a id="logo" href="/.">Corey's Blog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">koa和co的简单分析</h1><div class="post-meta">Sep 28, 2016<span> | </span><span class="category"><a href="/categories/备忘/">备忘</a></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#概述：简介及使用"><span class="toc-number">1.</span> <span class="toc-text">概述：简介及使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#简单使用"><span class="toc-number">1.1.</span> <span class="toc-text">简单使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#级联代码"><span class="toc-number">1.2.</span> <span class="toc-text">级联代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#处理异步操作"><span class="toc-number">1.3.</span> <span class="toc-text">处理异步操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#背景概念：遍历器和-Generator-函数"><span class="toc-number">2.</span> <span class="toc-text">背景概念：遍历器和 Generator 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Iterator-遍历器"><span class="toc-number">2.1.</span> <span class="toc-text">Iterator 遍历器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Generator-函数"><span class="toc-number">2.2.</span> <span class="toc-text">Generator 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#next-方法的参数"><span class="toc-number">2.3.</span> <span class="toc-text">next 方法的参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#yield-及-yield-语句"><span class="toc-number">2.4.</span> <span class="toc-text">yield 及 yield* 语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Generator-在异步流程控制中的使用"><span class="toc-number">2.5.</span> <span class="toc-text">Generator 在异步流程控制中的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重要工具：流程控制执行器co"><span class="toc-number">3.</span> <span class="toc-text">重要工具：流程控制执行器co</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考文档"><span class="toc-number">4.</span> <span class="toc-text">参考文档</span></a></li></ol></div></div><div class="post-content"><h3 id="概述：简介及使用"><a href="#概述：简介及使用" class="headerlink" title="概述：简介及使用"></a>概述：简介及使用</h3><p><em>本文先介绍 koa 的简单使用和一些背景概念，已经了解的可以跳过直接到 co 和 koa 执行分析部分。</em></p>
<p>koa的简介如下：</p>
<blockquote>
<p>由 Express 原班人马打造的 koa，致力于成为一个更小、更健壮、更富有表现力的 Web 框架。使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升常用错误处理效率。Koa 不在内核方法中绑定任何中间件，它仅仅提供了一个轻量优雅的函数库，使得编写 Web 应用变得得心应手。</p>
</blockquote>
<h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a><strong>简单使用</strong></h4><p>使用 koa 构建一个 web 应用有多简单？先来看一个使用例子 <code>app.js</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</div><div class="line"><span class="keyword">var</span> app = koa();</div><div class="line"></div><div class="line"><span class="comment">// 中间件</span></div><div class="line">app.use(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.body = <span class="string">'Hello World'</span>;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.listen(<span class="number">3000</span>);</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>运行使用命令 <code>$ node ./app.js</code> 就能在本机的 <code>3000</code> 端口启动一个web服务。</p>
<p>这里查看 koa 源码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">app.listen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  debug(<span class="string">'listen'</span>);</div><div class="line">  <span class="keyword">var</span> server = http.createServer(<span class="keyword">this</span>.callback());</div><div class="line">  <span class="keyword">return</span> server.listen.apply(server, <span class="built_in">arguments</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以发现事实上上文的 <code>app.listen(3000);</code> 可以改写为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> server = http.createServer(app.callback());</div><div class="line">server.listen(<span class="number">3000</span>);</div></pre></td></tr></table></figure>
<h4 id="级联代码"><a href="#级联代码" class="headerlink" title="级联代码"></a><strong>级联代码</strong></h4><blockquote>
<p>与 Connect 实现中间件的方法相对比，Koa 的做法不是简单的将控制权依次移交给一个又一个的中间件直到程序结束，Koa 执行代码的方式有点像回形针，用户请求通过中间件，遇到 yield next 关键字时，会被传递到下一个符合请求的路由（downstream），在 yield next 捕获不到下一个中间件时，逆序返回继续执行代码（upstream）。</p>
</blockquote>
<p>看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</div><div class="line"><span class="keyword">var</span> app = koa();</div><div class="line"></div><div class="line">app.use(<span class="function"><span class="keyword">function</span>* <span class="title">fun_a</span>(<span class="params">next</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'a-head'</span>);</div><div class="line">    <span class="keyword">yield</span> next;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'a-tail'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.use(<span class="function"><span class="keyword">function</span>* <span class="title">fun_b</span>(<span class="params">next</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'b-head'</span>);</div><div class="line"></div><div class="line">    <span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>;</div><div class="line">    <span class="keyword">yield</span> next;</div><div class="line">    <span class="keyword">var</span> ms = <span class="keyword">new</span> <span class="built_in">Date</span> - start;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'%s %s - %s'</span>, <span class="keyword">this</span>.method, <span class="keyword">this</span>.url, ms);</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'b-tail'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.use(<span class="function"><span class="keyword">function</span>* <span class="title">fun_c</span>(<span class="params">next</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.body = <span class="string">'Hello World'</span>;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.listen(<span class="number">3000</span>);</div></pre></td></tr></table></figure>
<p>每处理一个请求，console就会输出：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a-head</div><div class="line"><span class="keyword">b-head</span></div><div class="line"><span class="symbol">GET</span> / - <span class="number">4</span></div><div class="line"><span class="keyword">b-tail</span></div><div class="line">a-tail</div></pre></td></tr></table></figure>
<p>观察执行结果，很容易理解程序的运行顺序。首先会执行第一个中间件，但当执行到 yield next 时，代码流会暂停执行这个中间件的剩余代码，转而切换到下一个被定义的中间件执行代码。直到执行到最后一个没有 yield next 的中间件，该中间件返回后，程序流会按反向顺序执行每个中间件的剩余代码。</p>
<p>这被称为<code>“洋葱”</code>结构。可以形象地使用下图来表示：</p>
<p><img src="/images/20160928/ycjg.png" alt="洋葱结构"></p>
<p>具体对应到上文的例子，图可以画成这样：</p>
<p><img src="/images/20160928/yangcong.png" alt="洋葱结构"></p>
<h4 id="处理异步操作"><a href="#处理异步操作" class="headerlink" title="处理异步操作"></a><strong>处理异步操作</strong></h4><p>首先将异步操作封装为 Promise</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncOne</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">        doAsync(<span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span>(error)&#123;</div><div class="line">                reject(error);</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                resolve(data);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在中间件中如下调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ret = <span class="keyword">yield</span> asyncOne();</div><div class="line"><span class="built_in">console</span>.log(ret);</div></pre></td></tr></table></figure>
<p>可以看到这样执行异步操作，从代码顺序上看和一般的同步执行代码已经很类似了，易于理解代码业务逻辑，并能避免被复杂的异步回调搞晕。但事实上代码还是异步执行的，不存在线程等待。阮一峰老师提到过<code>协程</code>的概念，了解一下有助于这里的理解。</p>
<p>但是这样做有一个缺点是多个异步操作都是等待上一个操作完成后才开始执行，事实上是强制顺序执行了。比如如下的代码，两个异步执行其实并没有依赖关系，完全可以并行执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ret1 = <span class="keyword">yield</span> asyncOne1();</div><div class="line"><span class="keyword">var</span> ret2 = <span class="keyword">yield</span> asyncOne2();</div><div class="line"><span class="built_in">console</span>.log(ret1, ret2);</div></pre></td></tr></table></figure>
<p>这种情况下可以将多个异步操作合并，内部还是异步执行，外部同步等待。可以使用 Promise.all 来包裹多个 Promise。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncMulti</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all([</div><div class="line">        asyncOne(), asyncOne()</div><div class="line">    ]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在中间件中如下调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ret = <span class="keyword">yield</span> asyncMulti();</div><div class="line"><span class="built_in">console</span>.log(ret);</div></pre></td></tr></table></figure>
<h3 id="背景概念：遍历器和-Generator-函数"><a href="#背景概念：遍历器和-Generator-函数" class="headerlink" title="背景概念：遍历器和 Generator 函数"></a>背景概念：遍历器和 Generator 函数</h3><p>上文用到了关键字 yield，这是ES2015（ES6）中引入的概念，相关的概念还有 Iterator 遍历器和 Generator 函数。下面大部分的理解和解释都参考于阮一峰老师的《ECMAScript 6入门》一书。</p>
<p><em>下文还会更多提到异步回调和 Promise ，默认读者都了解，不再详述。</em></p>
<h4 id="Iterator-遍历器"><a href="#Iterator-遍历器" class="headerlink" title="Iterator 遍历器"></a><strong>Iterator 遍历器</strong></h4><p>遍历器是一种协议，只要符合这个协议就能完成遍历操作。ES6 的协议规定只要实现了 next 方法的对象都具备了遍历器的功能。next 方法返回的对象包含两属性，其中 value 表示当前遍历的值，done 是一个布尔值，表示是否遍历结束。</p>
<p>下面贴一个阮一峰老师书里的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> nextIndex &lt; array.length ?</div><div class="line">        &#123;<span class="attr">value</span>: array[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span>&#125; :</div><div class="line">        &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> it = makeIterator([<span class="string">'a'</span>, <span class="string">'b'</span>]);</div><div class="line"></div><div class="line">it.next() <span class="comment">// &#123; value: "a", done: false &#125;</span></div><div class="line">it.next() <span class="comment">// &#123; value: "b", done: false &#125;</span></div><div class="line">it.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></div></pre></td></tr></table></figure>
<p>上文 makeIterator 是一个遍历器生成函数，实现数组的遍历，next 函数执行时移动指针并返回当前遍历的值。</p>
<p>ES6还规定了，只要部署了next方法，就可以用for…of循环遍历它的值。for…of 和 for…in 的区别是后者只能获取对象的键名，而前者直接遍历了键值。事实上，数组原生就部署了遍历器的接口，可以如下实现遍历</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'yellow'</span>];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> arr)&#123;</div><div class="line">    <span class="built_in">console</span>.log(v);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">red</span></div><div class="line"><span class="built_in">blue</span></div><div class="line">yellow</div></pre></td></tr></table></figure>
<h4 id="Generator-函数"><a href="#Generator-函数" class="headerlink" title="Generator 函数"></a><strong>Generator 函数</strong></h4><blockquote>
<p>Generator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。</p>
</blockquote>
<p>Generator 函数事实上就是一个普通的函数，但是它有几点特殊：</p>
<ul>
<li>function 后面会有一个星号；</li>
<li>函数内部会使用 yield 定义状态，将函数分成几个部分；</li>
<li>函数运行结果返回一个遍历器。</li>
</ul>
<p>所以说Generator 函数就是一个遍历器生成器函数。</p>
<p>Generator 函数返回的遍历器有一个特殊的名字就叫 Generator。它是一个内部状态的遍历器，每一次遍历都是内部状态的一次改变，ES6引入这个特性之后就能控制函数内部的执行状态。</p>
<p>来看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</div><div class="line">  <span class="keyword">return</span> <span class="string">'ending'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</div></pre></td></tr></table></figure>
<p>如是，hw就是一个 Generator（状态遍历器），遍历的执行结果如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">hw.next()</div><div class="line"><span class="comment">// &#123; value: 'hello', done: false &#125;</span></div><div class="line"></div><div class="line">hw.next()</div><div class="line"><span class="comment">// &#123; value: 'world', done: false &#125;</span></div><div class="line"></div><div class="line">hw.next()</div><div class="line"><span class="comment">// &#123; value: 'ending', done: true &#125;</span></div><div class="line"></div><div class="line">hw.next()</div><div class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></div></pre></td></tr></table></figure>
<p>分析执行过程，我们可以看到 helloWorldGenerator 函数内部使用了两次 yield 关键字，它们将整个函数分成了三个部分，这三个部分以状态遍历器的形式作为函数返回结果被返回。当这个状态遍历器在被遍历时，每一次遍历就执行了函数的一个部分。yield 关键字后面的表达式值就是 next 方法的返回对象中的 value 值。当 done 为 true 时，表示函数内部的所有状态都已被执行。</p>
<p>事实上，我们可以把 Generator 函数理解为一种可以被暂停执行的函数，而使用遍历器的 next 方法控制函数的暂停和执行。</p>
<h4 id="next-方法的参数"><a href="#next-方法的参数" class="headerlink" title="next 方法的参数"></a><strong>next 方法的参数</strong></h4><p>next 方法是可以传入参数的，传入的参数将作为 yield 语句的执行结果。</p>
<p>先看代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params">p</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(p);</div><div class="line">    <span class="keyword">var</span> a = <span class="keyword">yield</span> <span class="string">'hello'</span>;</div><div class="line">    <span class="built_in">console</span>.log(a);</div><div class="line">    <span class="keyword">var</span> b = <span class="keyword">yield</span> <span class="string">'world'</span>;</div><div class="line">    <span class="built_in">console</span>.log(b);</div><div class="line">    <span class="keyword">return</span> <span class="string">'ending'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> hw = helloWorldGenerator(<span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(hw.next(<span class="number">1</span>));</div><div class="line"><span class="built_in">console</span>.log(hw.next(<span class="number">2</span>));</div><div class="line"><span class="built_in">console</span>.log(hw.next(<span class="number">3</span>));</div><div class="line"><span class="built_in">console</span>.log(hw.next(<span class="number">4</span>));</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">0</div><div class="line">&#123; <span class="attribute">value</span>: <span class="string">'hello'</span>, done: false &#125;</div><div class="line">2</div><div class="line">&#123; <span class="attribute">value</span>: <span class="string">'world'</span>, done: false &#125;</div><div class="line">3</div><div class="line">&#123; <span class="attribute">value</span>: <span class="string">'ending'</span>, done: true &#125;</div><div class="line">&#123; <span class="attribute">value</span>: undefined, done: true &#125;</div></pre></td></tr></table></figure>
<p>第一次遍历时，next 方法传入参数 <code>1</code>，并控制执行了第一部分代码，并返回了 yield 关键字后面的字符串作为 value 值。但是我们发现传入的 <code>1</code> 即没有给变量 <code>p</code> 也没有给变量 <code>a</code>，而是被丢掉了，而打印出来的 <code>p</code> 的值是 Generator 函数执行时传入的 <code>0</code>。第二次遍历时，next 方法传入参数 <code>2</code>，并控制执行了第二部分代码，此时我们才看到 next 传入的 <code>2</code> 作为 yield 语句的执行结果给了<code>a</code>。 </p>
<p>以图来理解更形象一点。</p>
<p><img src="/images/20160928/do.png" alt="next"></p>
<h4 id="yield-及-yield-语句"><a href="#yield-及-yield-语句" class="headerlink" title="yield 及 yield* 语句"></a><strong>yield 及 yield* 语句</strong></h4><p>yield 关键字上文已经讲到了，它后面跟的值将被直接作为 next 方法返回的 value 值。而当 yield 关键字后面跟的是 Generator 遍历器时，需要在 yield 后面加上星号 <code>*</code> 来表明。</p>
<p>还是用例子来解释它们之间的区别：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generator1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="string">'red'</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="string">'blue'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generator2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="string">'yellow'</span>;</div><div class="line">    <span class="keyword">yield</span> generator1();</div><div class="line">    <span class="keyword">yield</span> <span class="string">'grey'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> generator2())&#123;</div><div class="line">    sum ++;</div><div class="line">    <span class="built_in">console</span>.log(v);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(sum);</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="section">yellow</span></div><div class="line">&#123;&#125;</div><div class="line"><span class="attribute">grey</span></div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<p>generator1() 函数被调用时返回一个状态遍历器，当在它之前的 yiled 关键字不使用星号时，这个状态遍历器直接被作为 next 方法返回的 value值（例子中没有显式地使用next，而用了for…of方式），状态遍历器无法序列化，所以在打印时只打印了<code>{}</code>。</p>
<p>然后来看使用星号的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generator1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="string">'red'</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="string">'blue'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generator3</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="string">'yellow'</span>;</div><div class="line">    <span class="keyword">yield</span>* generator1();</div><div class="line">    <span class="keyword">yield</span> <span class="string">'grey'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> generator3())&#123;</div><div class="line">    sum ++;</div><div class="line">    <span class="built_in">console</span>.log(v);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(sum);</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">yellow</div><div class="line"><span class="built_in">red</span></div><div class="line"><span class="built_in">blue</span></div><div class="line">grey</div><div class="line"><span class="number">4</span></div></pre></td></tr></table></figure>
<p>generator1 函数被调用时还是返回了一个状态遍历器，但是不再仅当成一个值，而是被当成了外层状态遍历器的一部分。generator3 返回的就是这个外层状态遍历器，可以看到外部遍历器被遍历了5次(当done为true时并不会执行循环体内的代码，左移遍历次数等于sum + 1)，但是 generator3 只被分成了 <code>4</code> 部分。我们可以将上面的过程理解为下面这样一个合并的函数，这样就可以理解 generator3 返回的状态遍历器为什么被遍历了5次了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generator3</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="string">'yellow'</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="string">'red'</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="string">'blue'</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="string">'grey'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Generator-在异步流程控制中的使用"><a href="#Generator-在异步流程控制中的使用" class="headerlink" title="Generator 在异步流程控制中的使用"></a><strong>Generator 在异步流程控制中的使用</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>  <span class="title">asyncOne</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">        request.get(&#123;</div><div class="line">            <span class="attr">url</span>: <span class="string">'http://www.baidu.com'</span></div><div class="line">        &#125;, <span class="function"><span class="keyword">function</span> <span class="title">optionalCallback</span>(<span class="params">error, response, body</span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'in'</span> + response.statusCode);</div><div class="line">            resolve(response.statusCode);</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generator</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'step1'</span>);</div><div class="line">    <span class="keyword">yield</span> asyncOne();</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'step2'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> hm = generator();</div><div class="line"><span class="keyword">var</span> promise = hm.next().value;</div><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'out'</span> + data);</div><div class="line">    hm.next();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="重要工具：流程控制执行器co"><a href="#重要工具：流程控制执行器co" class="headerlink" title="重要工具：流程控制执行器co"></a>重要工具：流程控制执行器co</h3><p>co 是 TJ 结合 Generator 和 Promise 编写的执行器，实现以类似同步代码的方式来执行异步代码。</p>
<p>上文说到Generator函数能生成一个迭代器，操作迭代器来使内部代码分步执行。那么当Generator函数内有一步为异步操作时，可以使用Promise来控制等待异步执行结束之后再执行下一步。这是co原理的简单理解，也是上文<code>Generator 在异步流程控制中的使用</code>中讲到的方式基于的原理。当然，TJ 大神用简洁完备的代码对其进行了封装。</p>
<p>一般使用例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="literal">true</span>);</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.error(err.stack);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>例如上文代码中，假设Promise.resolve(true);部分代码替换为封装了异步执行函数的Promise，那么该步next()执行的返回值就是这个Promise。外部将能由这个Promise获知到异步函数什么时候执行结束，然后再继续执行下一步。具体逻辑用下文的源码来分析。</p>
<p>co的代码总共只有200多行，而关键代码去掉注释甚至只有如下不到50行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">var</span> args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">'function'</span>) gen = gen.apply(ctx, args);</div><div class="line">        <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.next !== <span class="string">'function'</span>) <span class="keyword">return</span> resolve(gen);</div><div class="line"> </div><div class="line">        onFulfilled();</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> ret;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                ret = gen.next(res);</div><div class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">                <span class="keyword">return</span> reject(e);</div><div class="line">            &#125;</div><div class="line">            next(ret);</div><div class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> ret;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                ret = gen.throw(err);</div><div class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">                <span class="keyword">return</span> reject(e);</div><div class="line">            &#125;</div><div class="line">            next(ret);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">ret</span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span> (ret.done) <span class="keyword">return</span> resolve(ret.value);</div><div class="line">            <span class="keyword">var</span> value = toPromise.call(ctx, ret.value);</div><div class="line">            <span class="keyword">if</span> (value &amp;&amp; isPromise(value)) <span class="keyword">return</span> value.then(onFulfilled, onRejected);</div><div class="line">            <span class="keyword">return</span> onRejected(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'You may only yield a function, promise, generator, array, or object, '</span></div><div class="line">                + <span class="string">'but the following object was passed: "'</span> + <span class="built_in">String</span>(ret.value) + <span class="string">'"'</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>co函数传入的参数是一个Generator函数，而返回值是一个Promise。</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://github.com/guo-yu/koa-guide" target="_blank" rel="external">koa 中文文档</a></p>
<p><a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">ECMAScript 6入门</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="https://corey600.github.io/2016/09/28/koa-and-co/" data-id="cj0vrn65f001mv0qdmmorzpks" class="article-share-link">分享到</a><div class="tags"><a href="/tags/前端/">前端</a><a href="/tags/koa/">koa</a><a href="/tags/co/">co</a></div><div class="post-nav"><a href="/2016/12/15/node-performance-analysis/" class="pre">由一个简单Node服务引申的Node性能分析方法</a><a href="/2016/08/03/node-dubbo/" class="next">使用node开发dubbo远程调用客户端</a></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/备忘/">备忘</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/总结/">总结</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/转载/">转载</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/12/15/node-performance-analysis/">由一个简单Node服务引申的Node性能分析方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/28/koa-and-co/">koa和co的简单分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/03/node-dubbo/">使用node开发dubbo远程调用客户端</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/22/private-npm-service/">私有NPM服务搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/13/gulp-workflow/">gulp前端构建工作流</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/04/flash-player/">Flash播放器研究</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/11/vagrant-instructions/">使用vagrant虚拟机开发调试</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/07/07/js-class-inheritance/">JS的类和继承的实现方法比较</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/06/16/fiddler-instructions/">Fiddler使用说明</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/09/18/mktime-daylight/">标准库函数mktime与夏令时</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/夏令时/" style="font-size: 15px;">夏令时</a> <a href="/tags/ACM/" style="font-size: 15px;">ACM</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/串口/" style="font-size: 15px;">串口</a> <a href="/tags/VBox/" style="font-size: 15px;">VBox</a> <a href="/tags/LCD/" style="font-size: 15px;">LCD</a> <a href="/tags/Vim/" style="font-size: 15px;">Vim</a> <a href="/tags/Ubuntu/" style="font-size: 15px;">Ubuntu</a> <a href="/tags/SublimeText2/" style="font-size: 15px;">SublimeText2</a> <a href="/tags/G/" style="font-size: 15px;">G++</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Github/" style="font-size: 15px;">Github</a> <a href="/tags/Octopress/" style="font-size: 15px;">Octopress</a> <a href="/tags/Win7/" style="font-size: 15px;">Win7</a> <a href="/tags/字符串/" style="font-size: 15px;">字符串</a> <a href="/tags/Jekyll/" style="font-size: 15px;">Jekyll</a> <a href="/tags/前端/" style="font-size: 15px;">前端</a> <a href="/tags/Fiddler/" style="font-size: 15px;">Fiddler</a> <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/TQ2440/" style="font-size: 15px;">TQ2440</a> <a href="/tags/flash/" style="font-size: 15px;">flash</a> <a href="/tags/播放器/" style="font-size: 15px;">播放器</a> <a href="/tags/vagrant/" style="font-size: 15px;">vagrant</a> <a href="/tags/nfs/" style="font-size: 15px;">nfs</a> <a href="/tags/fis/" style="font-size: 15px;">fis</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/类/" style="font-size: 15px;">类</a> <a href="/tags/继承/" style="font-size: 15px;">继承</a> <a href="/tags/npm/" style="font-size: 15px;">npm</a> <a href="/tags/cnpm/" style="font-size: 15px;">cnpm</a> <a href="/tags/gulp/" style="font-size: 15px;">gulp</a> <a href="/tags/webpack/" style="font-size: 15px;">webpack</a> <a href="/tags/koa/" style="font-size: 15px;">koa</a> <a href="/tags/co/" style="font-size: 15px;">co</a> <a href="/tags/node/" style="font-size: 15px;">node</a> <a href="/tags/dubbo/" style="font-size: 15px;">dubbo</a> <a href="/tags/Node/" style="font-size: 15px;">Node</a> <a href="/tags/性能/" style="font-size: 15px;">性能</a></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Corey's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>